
#define pioAY595 pio1
#define sm_AY595 1
#define CLK_LATCH_595_BASE_PIN (26)
#define DATA_595_PIN (28)
#define CLK_AY_PIN (29)

uint16_t ay595;
uint16_t beep595;
uint8_t beep_data_old;
uint8_t beep_data;

//==============================================================

// программа  стейт машины для работы с регистром сдвига 595 c задержкой
static const uint16_t program_instructions595[] = {
            //     .wrap_target
    0x80a0, //  0: pull   block                      
    0x6101, //  1: out    pins, 1                [1] 
    0x1141, //  2: jmp    x--, 1                 [17]
    0xea2f, //  3: set    x, 15                  [10]
            //     .wrap
};
//---------------------------------------------
static const struct pio_program program595 = {
    .instructions = program_instructions595,
    .length = 4,
    .origin = -1,
};
// PWM для 595
static void PWM_init_pin(uint pinN)
    {
        gpio_set_function(pinN, GPIO_FUNC_PWM);
        uint slice_num = pwm_gpio_to_slice_num(pinN);
        
        pwm_config c_pwm=pwm_get_default_config();
        pwm_config_set_clkdiv(&c_pwm,clock_get_hz(clk_sys)/(4.0*1750000));
        pwm_config_set_wrap(&c_pwm,3);//MAX PWM value
        pwm_init(slice_num,&c_pwm,true);
    }
  //   pwm_set_gpio_level(CLK_AY_PIN,0); // отключение AY по частоте
  //   pwm_set_gpio_level(CLK_AY_PIN,2);// включение AY по частоте
//--------------------------------------------------------------
void Init_AY_595()
{
    PWM_init_pin(CLK_AY_PIN);
    pwm_set_gpio_level(CLK_AY_PIN,2);

    uint offset = pio_add_program(pioAY595, &program595);
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset, offset + (program595.length-1)); 
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);
    
    //настройка side set
    sm_config_set_sideset_pins(&c,CLK_LATCH_595_BASE_PIN);
    sm_config_set_sideset(&c,2,false,false);
    for(int i=0;i<2;i++)
        {           
            pio_gpio_init(pioAY595, CLK_LATCH_595_BASE_PIN+i);
        }
    
    pio_sm_set_pins_with_mask(pioAY595, sm_AY595, 3u<<CLK_LATCH_595_BASE_PIN, 3u<<CLK_LATCH_595_BASE_PIN);
    pio_sm_set_pindirs_with_mask(pioAY595, sm_AY595,  3u<<CLK_LATCH_595_BASE_PIN,  3u<<CLK_LATCH_595_BASE_PIN);
    //


    
    pio_gpio_init(pioAY595, DATA_595_PIN);//резервируем под выход PIO
  
    pio_sm_set_consecutive_pindirs(pioAY595, sm_AY595, DATA_595_PIN, 1, true);//конфигурация пинов на выход

    sm_config_set_out_shift(&c, false, false, 32);
    sm_config_set_out_pins(&c, DATA_595_PIN, 1);

    pio_sm_init(pioAY595, sm_AY595, offset, &c);
    pio_sm_set_enabled(pioAY595, sm_AY595, true);

    float fdiv=(clock_get_hz(clk_sys)/80000000);//частота 50 MHz
    uint32_t fdiv32=(uint32_t) (fdiv * (1 << 16));
    fdiv32=fdiv32&0xfffff000;//округление делителя
    pioAY595->sm[sm_AY595].clkdiv=fdiv32; //делитель для конкретной sm

    pioAY595->txf[sm_AY595]=0;
    pioAY595->txf[sm_AY595]=0;

/*     тест при включении
       for (int i = 0; i < 4; i++)
     {  
      send595(0b00001100 ,0x00);// включение светодиодов
      sleep_ms(100);
      send595(0b00001100 ,0x00);// выключение светодиодов
      sleep_ms(100);
     }
      send595(0b01000000 ,0x00);// выключение светодиодов
 */
    
};
//------------------------------------------------------------------
// SEND 595 command , data
void __not_in_flash_func(send595)(uint16_t comand,uint8_t data)
{  
            
    ay595 = (comand << 8) | data;

     uint16_t reg595 = ay595 |beep595;

    pioAY595->txf[sm_AY595]=reg595<<16;
  }
//-----------------------------------------------------------------------